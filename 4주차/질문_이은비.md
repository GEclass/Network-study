# Review

## 1. 인증 (Authentication)이란

인증이란 네트워크와 시스템을 이용하는 사용자 또는 기기가 정식으로 등록됐는지 확인하는 절차이다.
- 인증을 통해 정식 사용자 이외에는 네트워크나 시스템에 접근할 수 없게 한다.

## 인증 (Authentication) vs 인가 (Authorization)

인증이란 유저가 누구인지 확인하는 절차로서 회원가입 및 로그인을 의미한다.
- 인증에는 **아이디, 이메일 주소, 비밀번호** 등등이 필요하다.

반면, 인가란 유저에 대한 권한을 허락하는 것이다.
- HTTP는 Stateless 하므로 매 요청마다 헤더를 활용하여 사용자가 인증 절차를 거친 사용자임을 증명하는 정보를 담아서 보내는 방법이다.
  - JWT (Json Web Token)

### JWT (Json Web Token)
> https://velog.io/@chyoon0512/%EC%9D%B8%EC%A6%9D%EC%9D%B8%EA%B0%80-%EB%9E%80-JWTJSON-web-token
> https://velog.io/@hahan/JWT%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

![image](https://github.com/GEclass/Network-study/assets/103405457/1d5511d8-4d0a-4c3e-bd82-af8c51314416)

- 헤더 : "어떤 알고리즘으로 암호화를 진행할 것인지" + "어떤 토큰을 사용할 것인지"
- 정보 : 전달하려는 정보(사용자 id 등) + 권한의 범위 or TTL
- 서명 : 헤더 + 정보를 합친 후, 발급한 서버가 지정한 비밀키로 헤더에 저장된 해싱 암호화 알고리즘을 통해 암호화하여 전송

동작 과정은 다음과 같다.

![image](https://github.com/GEclass/Network-study/assets/103405457/19b55ef4-55a2-4cfb-b0dc-9ce343737bc6)

1. 사용자가 아이디 및 비밀번호를 통해 로그인 요청을 한다.
2. 서버는 유저 DB에 존재하는 사용자인지 확인한다.
3. 확인이 되면 서버는 로그인 요청 **확인**과 함께 비밀키를 통해 **토큰**을 발급한다.
4. 클라이언트는 서비스 요청과 권한을 확인하기 위해서 헤더에 데이터 **요청**과 함께 **토큰**을 발송한다.
5. 데이터와 함께 **토큰**에서 사용자 정보를 확인한다.
6. 클라이언트 요청에 대한 **응답** 및 요청 데이터를 전달한다.

## 2. 암호화란?

네트워크 상에서 전송되는 데이터는 제 3자에게 도청될 위험이 있다.
- 따라서 데이터 도청을 방지하기 위해 데이터를 암호화한다.

### 데이터 암호화란?

데이터를 암호화함으로써 정식 사용자 이외에는 그 데이터의 내용을 판별할 수 없게한다.
- 만일, 네트워크 사에서 전송될 때 제 3자에게 도청되더라도 데이터의 내용을 판별할 수 없다.

평문 (암호화하기 전의 데이터)을 암호화하기 위해서 암호키를 이용한다.
- 이때, 암호키란 특정한 비트 수로 된 수치이다.

즉, 암호화란 평문 + 암호키로 수학적 연산을 거쳐 암호화된 데이터인 **암호문**을 생성하는 것이다.

### 데이터 복호화란?

암호문 + 암호키를 이용해 암호화와 반대로 연산하여 **평문**으로 되돌리는 것을 복호라고 한다.

## 3. 대칭키 암호방식 (= 공통키 암호 방식, 비밀키 암호 방식)
> https://brunch.co.kr/@artiveloper/24

대칭키 암호방식이란 **암호화**와 **복호화**에 같은 암호키를 이용하는 암호화 방식이다.
- 또는 **공통키 암호방식** 또는 **비밀키 암호방식** 등으로 불리운다.

과정은 다음과 같다.

1. 송신자와 수신자가 미리 같은 암호키를 공유하도록 한다.
2. 데이터(평문)를 암호키를 이용해 암호화를 해서 암호 데이터를 만든다.
3. 수신자에게 암호 데이터를 전달한다.
4. 수신자는 가지고 있던 암호키를 통해 복호화를 진행하여 데이터를 읽는다.

위와 같이 암호키에 대한 특징은 다음과 같다.
1. 송신자와 수신자가 모두 공유하고 있어야 한다.
2. 암호키는 주기적으로 갱신시켜야 한다.
- 같은 암호키를 계속 사용할 경우, 암호 데이터의 규칙성에서 암호가 해독될 위험이 커지기 때문

주요 대칭키 암호화의 알고리즘으로는 **3DES**와 **AES**가 있다.

## 4. 공개키 암호방식

공개키 암호방식은 암호키 쌍인 공개키와 비밀키로 암호화를 진행하는 방식이다.

과정은 다음과 같다.

1. 송신자는 수신자가 공개한 공개키를 입수한다.
2. 공개키로 데이터를 암호화해서 전송한다.
3. 공개키로 암호화된 데이터를 비밀키로 복호화를 수행한다.

키에 대한 특징은 다음과 같다.
1. 공개키는 public하다. 즉, 누구나 암호화할 수 있다.
2. 하지만, 비밀키는 private하다. 즉, 수신자만 가지고 있으며 누구나 복호화할 수 없다.

## 5. 비밀키란?

공통키(= 대칭키), 공개키 암호방식뿐만 아니라 비밀키 암호방식도 존재한다.

역으로 비밀키로 암호화를 진행한 후, 공개키로 복호화하는 방식으로 과정은 다음과 같다.

1. 송신자는 공개키와 비밀키 쌍을 생성하고 공개키를 공개한다.
2. 비밀키로 데이터를 암호화한 후 암호 데이터를 전송한다.
3. 수신자는 A의 공개키를 입수하여 공개키로 복호화를 진행한다.
- 데이터를 암호화해서 보낸 사람이 A임을 확인할 수 있다.

비밀키 암호방식의 알고리즘으로는 **RSA 암호**와 **타원곡선 암호**가 존재한다.
- 소인수 분해, 이산대수

## 6. 디지털 서명이란?

비밀키로 암호화한 데이터를 공개키로 복호화할 수 있다는 원리를 이용하여 데이터를 보낸 곳과 데이터가 변조되지 않았음을 확인하기 위해 디지털 서명이 있다.
- 데이터를 보낼 때, 서명용 데이터를 추가해서 전송
  - 수신하는 쪽에서 서명 데이터를 체크함으로써 데이터가 변조되지 않았음 + 송신자를 파악할 수 있게 된다.
    - 데이터의 해시값을 비밀키로 암호화
     
과정은 다음과 같다.

1. **송신자**가 보낼 데이터에서 해시값 (정해진 순서대로 계산하여 얻은 고정 길이의 값)을 생성한다.
2. 생성된 해시값을 송신자의 비밀키로 암호화하여 **서명 데이터**를 작성한다.
3. 송신자는 **데이터**와 **서명 데이터**를 함께 수신자에게 전송
4. 수신자는 송신자의 공개키를 이용해 서명 데이터를 복호화한다.
5. 수신자는 수신한 데이터로부터 해시값을 생성
6. 수신자가 생성한 해시값과 서명의 해시값을 비교

### CA 인증서란?

공개키 암호 방식 (공개키-비밀키)를 기반으로 디지털 인증서에는 공개키가 포함이 된다.
- 이때, 신뢰할 수 있는 인증기관인 CA (Certification Authority)에 디지털 발행서를 신청한다.
  - 이러한 디지털 발행서는 서버 등에 설치해 이용한다.
 
## 7. SSL(Secure Socket Layer)과 TSL(Transport Layer Security)

SSL은 프로토콜로서 웹 상에서 보내는 데이터를 암호화해서 도청을 방지한다.
- 클라이언트 - 서버 간에 HandShaking을 통해 인증이 이루어진다.
- 디지털 서명을 통해 데이터가 조작된 여부를 확인한다.

TSL은 웹에서 텍스트 형태로 전송되므로 암호화를 통해 안전하게 통신하기 위한 프로토콜이다.

## 8. VPN

..
