# [Network] 4주차 질문
## Q1. TCP/IP 계층에는 무엇이 있는가?
- 애플리케이션의 기능을 실행하기 위한 데이터 형식과 절차를 결정하는 즉, 데이터를 문자와 이미지 등으로 표현하는 애플리케이션 층과 애플리케이션에서 데이터를 할당하며 데이터를 적절한 애플리케이션에 배분하는 트랜스포트 층, 엔드 투 엔드 통신을 하는 인터넷 층, 네트워크 안에서 데이터를 전송하는 네트워크 인터페이스 층이 있습니다.
- ---
## Q2. OSI 계층은 무엇인가?
- 데이터를 전기 신호로 변환하여 주고 받는 물리 계층과 MAC 주소를 프레임에 부여하고 에러를 검출하고 흐름을 제어하는 데이터 링크 계층이 있습니다. 이동할 경로를 선택해서 IP 주소를 지정하여 그 경로로 데이터를 전달하는 네트워크 계층이 있고 TCP와 UDP 프로토콜을 통해 포트를 열고 전송하는 전송 계층이 있습니다. TCP/IP 세션을 만들고 없애는 책임을 가지는 세션 계층, 데이터 표현에 대한 독립성을 제공하고 데이터를 암호화하는 표현 계층이 있으며 응용 프로세스와 직접 관계하여 응용 서비스를 수행하는 응용 계층으로 구성되어 있습니다.
### TCP/IP 계층과 OSI 계층의 차이는 무엇인가?
- OSI 7계층은 데이터 통신의 과정을 7개의 계층으로 분류한 모델이고, TCP/IP 4계층은 실제로 사용되는 프로토콜 스택입니다.
- OSI는 네트워크 구조를 명확하게 설명할 수 있는 개념적 모델이고, TCP/IP는 실제 인터넷 통신에 사용되고 있는 실전형 모델입니다.
- TCP/IP의 애플리케이션 계층은 OSI의 애플리케이션, 세션, 프레젠테이션 계층을 통합한 포지션입니다. TCP/IP 모델의 인터넷 계층은 OSI 모델의 네트워크 계층에 대응하며, TCP/IP 모델의 네트워크 계층은 OSI의 데이터 링크, 물리 계층과 대응합니다.
- OSI 모델이 먼저 개발된 다음 네트워크 아키텍처의 요구에 맞게 프로토콜이 만들어졌지만 TCP/IP 계층은 프로토콜이 먼저 개발되고 TCP/IP 모델이 구축됐습니다.
---
## Q3. TCP의 전송 절차는 어떻게 되는가?
- TCP 커넥션 맺는 과정은
	1. 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 보냅니다.
		- 클라이언트는 응답을 기다리는 SYN_SENT 상태가 됩니다.
	2. 서버는 SYN 패킷을 받고 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송합니다.
		- 서버는 응답을 기다리는 SYN_RECEIVED 상태가 됩니다.
	3. 클라이언트는 서버에 ACK를 보냅니다.
		- 서버와 클라이언트는 ESTABLISHED 상태가 됩니다.
- TCP 커넥션을 끊는 과정은
	1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송합니다.
		- 클라이언트는 서버가 확인했다는 신호를 기다리는 FIN-WAIT 상태가 됩니다.
	2. 서버가 FIN 플래그를 받고 확인했다는 ACK를 보냅니다.
		- 서버는 자신의 통신이 끝날 때까지 CLOSE_WAIT 상태가 됩니다.
	3. 서버가 연결을 종료할 준비가 되면 연결 해지를 위한 준비가 되었음을 알리기 위해 FIN 플래그를 전송합니다.
		- 서버는 LAST-ACK 상태가 됩니다.
	4. 클라이언트는 해지 준비가 되었다는 ACK를 서버에 보냅니다.
		- 클라이언트는 TIME-WAIT가 되며 일정 시간이 지나면 세션을 만료하고 연결을 종료시키며 CLOSED 상태로 변화합니다. 서버는 ACK를 받고 CLOSED 상태가 됩니다.
---
## Q4. TCP와 UDP는 무엇이고 TCP와 UDP의 차이는 무엇인가?
- TCP란 신뢰성 있는 애플리케이션 간의 데이터 전송을 하기 위한 프로토콜입니다. 애플리케이션 간의 신뢰성있는 데이터 전송을 하는 TCP에서는 적절한 애플리케이션 프로토콜에 데이터를 배분할 수 있는 TCP 헤더의 포트 번호가 중요합니다. UDP는 데이터를 적절한 애플리케이션에 배분하는 프로토콜입니다. TCP는 연결형 프로토콜이며 UDP는 비연결형 프로토콜입니다. TCP는 신뢰성있는 데이터 전송을 하며 데이터 재전송을 하지만 UDP는 비신뢰성 데이터 전송을 하며 데이터 재전송을 하지 않습니다. TCP는 유니캐스트 통신만을 하지만 UDP는 유니캐스트, 브로드캐스트, 멀티캐스트 통신을 합니다.
---
## Q5. DNS는 무엇이고 어떠한 과정으로 사용하는가?
- 호스트 이름에 대응하는 IP 주소로 변환하는 역할을 합니다. 
	1. 클라이언트가 URL을 DNS에 보냅니다.
	2. DNS가 URL에 해당하는 IP 주소를 루트 도메인부터 질의하여 클라이언트에게 보냅니다.
	3. 클라이언트가 DNS로 알아낸 IP 주소로 서버에 접속합니니다.
---
## Q6. URL, URI, URN의 차이는 무엇인가?
- URI는 인터넷에 있는 자원을 어디에 있는지 자원 자체를 식별하는 통합 자원 식별자이고 URL은 네트워크 상에서 자원이 어디 있는지 알리는 위치입니다. URN은 웹 문서의 물리적인 위치와 상관없이 리소스의 이름인 웹 문서 자체입니다.
---
## Q7. HTTP는 무엇이고 HTTP를 사용 시, 웹 사이트가 어떻게 동작하는가?
- 하이퍼 텍스트를 전송하는 프로토콜입니다. HTTP 통신을 하기 전에 웹 브라우저와 웹 서버 애플리케이션은 TCP 커넥션을 맺으며 HTTP 리퀘스트와 HTTP 리스폰스를 주고 받으며 파일 전송을 합니다.
  - 하이퍼 텍스트란, 참조 링크(하이퍼링크)를 통해 즉시 다른 문서로 접근할 수 있는 텍스트입니다.
---
## Q8. HTTP Request, HTTP Response의 구조는 어떻게 이루어지는가?
- HTTP는 클라이언트가 HTTP request를 하면 서버가 HTTP response를 보내는 구조입니다. 
- 이 구조에서 HTTP response는 start line, HTTP Headers, 공백, body로 이루어져 있습니다.
  - start line은 HTTP 메소드, HTTP target(URI/URL), HTTP 버전으로 나누어집니다.
	  - HTTP 메소드는 해당 request가 의도한 action을 나타내는 부분입니다.
	  - HTTP target은 request가 전송되는 곳입니다.
	  - HTTP 버전은 응답 메세지에 써야 할 HTTP 버전을 알려주는 부분입니다.
  - HTTP Headers는 :으로 구분된 키와 값으로 이루어집니다. 또한 Request Header, General Header, Entity Header로 이루어져 있습니다.
	  - HTTP Header는 request에 대한 추가 정보를 가지고 있습니다.
	  - 예를 들어, 요청이 전송되는 target의 host url, 요청을 보내는 클라이언트의 대한 정보, 해당 요청이 받을 수 있는 response 타입, 해당 요청이 끝난후에 클라이언트와 서버가 계속해서 네트워크 컨넥션을 유지할 것인지 아니면 끊을 것인지에 대해 지시하는 부분 등이 있습니다.
  - body는 해당 request의 실제 메세지 내용입니다.
	  - HTTP 메소드가 GET, HEAD, DELETE 등과 같을 경우, request에 body가 없습니다.
- HTTP request에 대한 서버의 답변입니다. start line, HTTP Headers, 공백, body로 이루어져 있습니다.
  - start line은 HTTP 버전, Status Code, Status Text로 이루어져 있습니다.
	  - States Code는 응답의 상태를 나타내는 숫자 코드입니다.
	  - Status Text는 Status Code를 간략히 설명한 부분입니다.
  - HTTP Headers는 :으로 구분된 키와 값으로 이루어집니다. 또한 Response Header, General Header, Entity Header로 이루어져 있습니다.
	  - HTTP Header는 서버에 대한 추가 정보를 가지고 있습니다.
  - body는 response할 데이터가 있는 부분입니다.
	  - 서버가 데이터가 잘 도착했다는 응답 처럼 body가 없는 response도 있습니다.
### 사용되는 메소드인 GET과 POST의 차이는 무엇인가?
- GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식이고 POST는 데이터를 추가하거나 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다. GET은 URL에 데이터가 노출되기 때문에 보안적으로 중요한 데이터를 포함해서는 안되지만 POST는 URL에 데이터가 노출되지 않습니다.
---
## Q9. HTTP와 HTTPS를 비교하여 설명하라.
- HTTP는 평문 데이터를 전송하는 프로토콜로 비밀번호나 주민번호 등을 주고 받을 때, 제 3자에 의해 조회될 수 있습니다. 그래서 HTTP에 암호화가 추가된 프로토콜, HTTPS를 사용하며 대칭 키 암호화와 비대칭 키 암호화를 사용합니다.
- HTTPS는 서버와 클라이언트가 최초 1회로 서로 대칭 키를 공유하는 과정에서 비대칭 키 암호화를 사용하고 이후 메시지를 주고 받을 때는, 대칭 키 암호화를 사용합니다.
---
## Q10. HTTP 쿠키란 무엇인가?
- HTTP는 상태가 없습니다. 각각의 요청/응답은 연결되어 있지 않아 하나의 클라이언트가 보낸 여러 요청을 보낼 경우, 서버는 같은 클라이언트가 보냈다는 것은 알지 못합니다.
- 서버에 요청한 사람이 누구인지 표시하기 위해 클라이언트에 남기는 것이 쿠키입니다. HTTP의 특징인 무상태는 서버 입장에서 클라이언트의 상태가 없다는 것으로 매번 클라이언트가 보내는 요청은 독립적입니다.
	- 클라이언트가 서버에 요청을 하는 것이 처음이라면 서버는 쿠키를 응답과 함께 보냅니다. 이후, 클라이언트가 쿠키를 보낸 서버에 다시 요청할 경우, 서버에 요청과 쿠키를 같이 보냅니다. 요청과 쿠키를 받은 서버는 클라이언트를 확인하고 쿠키를 업데이트해야 한다면 업데이트한 쿠키와 함께 응답합니다.
	- 웹 브라우저가 종료되면 삭제되거나 만료일이 되면 삭제됩니다.
	- 쿠키를 통해 여러 페이지를 이동할 때마다 로그인을 하지 않고 사용자 정보를 유지할 수 있습니다.
	- 하지만 서버가 가지고 있는 것이 아니라 클라이언트가 저장하고 있기 때문에 임의로 고치거나 가로챌 수 있어 민감하거나 중요한 정보를 담는다면 위험하여 보안에 취약합니다.
---
## Q11. HTTP 세션 전달 과정을 설명하라.
- HTTP 세션이란 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와 HTTP 통신을 끝날 때까지의 기간이며 서버에 상태나 데이터를 저장해두고 세션 쿠키를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있는 방식입니다.
- 서버에서 세션 객체를 생성하여 각 클라이언트마다 고유한 세션 ID를 부여하며 쿠키를 사용하여 세션 ID를 클라이언트에 보냅니다. 서버가 클라이언트의 HTTP 요청에서 쿠키를 확인하여 세션 ID가 있는지 확인합니다. 세션 ID가 없다면 서버에서 세션 ID를 생성하여 응답할 때 쿠키에 담아 보냅니다. 클라이언트는 응답 받은 세션 ID를 저장하고 세션 ID를 생성한 서버에 요청 시, 세션 ID로 클라이언트를 인증합니다.
---
## Q12. 프록시 서버를 경우하는 웹 접속 과정을 설명하라.
- 프록시 서버는 웹 사이트 접속을 대행하는 서버입니다.
- 프록시 서버는 대행을 해줌으로써 외부 인터넷에서 클라이언트의 정보를 알 수 없습니다. 프록시에 있는 로컬 캐시를 통해 캐싱을 하며 리소스에 대한 접근 속도를 높입니다.
- 웹 브라우저에서 프록시 서버의 IP 주소와 포트 번호를 설정합니다.
	- TCP의 경우, 포트 번호 8080를 사용하여 접속합니다.
1. 클라이언트 웹 브라우저에서 URL을 입력하면 프록시 서버로 HTTP Request를 보냅니다.
2. 프록시 서버에서 URL로 저장된 웹 서버에 HTTP Request를 보냅니다.
	- 하지만 여기서 Request가 요청한 데이터와 페이지가 이미 로컬 캐시에 있다면 프록시 서버가 캐시에 있는 요청한 데이터와 페이지로 HTTP Response를 보냅니다.
3. 웹 서버가 다시 HTTP Response를 프록시 서버로 보내면 클라이언트 웹 브라우저로 HTTP Response를 보냅니다.
---
## Q13. 웹 서버와 웹 애플리케이션 서버의 차이는 무엇인가?
- 웹 서버는 정적 콘텐츠를 제공하고 웹 애플리케이션 서버는 비즈니스 로직에 따라 처리된 동적 콘텐츠를 제공합니다.
	- 그리고 웹 서버는 HTTP를 기본적으로 사용하며 FTP나 SMTP를 지원하기도 합니댜.
- 웹 애플리케이션 서버는 웹 서버에서 사용되는 프로토콜 외에도 추가 통신 프로토콜(원격 메서드 호출-RMI, 원격 프로시저 호출-RPC)을 사용하여 통신합니다.
- 웹 서버는 멀티 스레딩을 지원하지 않지만 웹 애플리케이션은 멀티 스레딩을 지원하여 한 번에 많은 클라이언트 상호 작용을 병렬로 처리할 수 있습니다.
---
## Q14. 공개키(비대칭키)를 설명하라.
- 데이터를 암호화할 때 공개키를 사용하고 암호화된 데이터를 복호할 때 비밀키를 사용하는 방식입니다. 누구나 데이터를 공개키로 암호화할 수 있지만 데이터를 복호할 수 있는 사용자는 제한할 수 있습니다. 이 외 비밀키로 암호화하고 공개키로 복호하는 방식도 있습니다. 이 경우, 공개키로 복호하였으므로 암호화하여 보낸 사람이 누구인지 공개키로 알 수 있습니다.
### 공개키와 비밀키(대칭키) 암호화 차이는 무엇인가?
- 비밀키(대칭키)는 데이터를 암호화하고 복호하는 키가 같은 방식입니다. 그래서 암호키를 공유하기 어렵고 보안이 안전하지 않지만 속도가 빠르다는 장점이 있습니다. 공개키(비대칭키)는 데이터를 암호화하고 복호화하는 키가 각각 달라 데이터가 해독될 위험이 작지만 속도가 느리다는 단점을 가지고 있습니다.
---
